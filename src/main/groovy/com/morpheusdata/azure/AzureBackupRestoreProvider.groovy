package com.morpheusdata.azure

import com.morpheusdata.azure.services.ApiService
import com.morpheusdata.azure.util.AzureBackupUtility
import com.morpheusdata.core.MorpheusContext
import com.morpheusdata.core.Plugin
import com.morpheusdata.core.backup.BackupRestoreProvider
import com.morpheusdata.core.backup.response.BackupRestoreResponse
import com.morpheusdata.core.data.DataFilter
import com.morpheusdata.core.data.DataQuery
import com.morpheusdata.core.util.HttpApiClient
import com.morpheusdata.response.ServiceResponse;
import com.morpheusdata.model.BackupRestore;
import com.morpheusdata.model.BackupResult;
import com.morpheusdata.model.Backup;
import com.morpheusdata.model.Instance
import groovy.util.logging.Slf4j

@Slf4j
class AzureBackupRestoreProvider implements BackupRestoreProvider {

	Plugin plugin
	MorpheusContext morpheusContext
	ApiService apiService

	AzureBackupRestoreProvider(Plugin plugin, MorpheusContext morpheusContext) {
		this.plugin = plugin
		this.morpheusContext = morpheusContext
		this.apiService = new ApiService(morpheusContext)
	}
	
	/**
	 * Returns the Morpheus Context for interacting with data stored in the Main Morpheus Application
	 * @return an implementation of the MorpheusContext for running Future based rxJava queries
	 */
	MorpheusContext getMorpheus() {
		return morpheusContext
	}

	/**
	 * Add additional configurations to a backup restore. Morpheus will handle all basic configuration details, this is a
	 * convenient way to add additional configuration details specific to this backup restore provider.
	 * @param backupResultModel backup result to be restored
	 * @param config the configuration supplied by external inputs
	 * @param opts optional parameters used for configuration.
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse configureRestoreBackup(BackupResult backupResult, Map config, Map opts) {
		return ServiceResponse.success()
	}

	/**
	 * Build the configuration for the restored instance.
	 * @param backupResultModel backup result to be restored
	 * @param instanceModel the instance the backup was created from, if it still exists. Retained backups will not have a reference to the instance.
	 * @param restoreConfig the restore configuration generated by morpheus.
	 * @param opts optional parameters used for configuration.
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse getBackupRestoreInstanceConfig(BackupResult backupResult, Instance instanceModel, Map restoreConfig, Map opts) {
		return ServiceResponse.success()
	}

	/**
	 * Verify the backup restore is valid. Generally used to check if the backup and instance are both in a state
	 * compatible for executing the restore process.
	 * @param backupResultModel backup result to be restored
	 * @param opts optional parameters used for configuration.
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse validateRestoreBackup(BackupResult backupResult, Map opts) {
		return ServiceResponse.success()
	}

	/**
	 * Get restore options to configure the restore wizard. Although the {@link com.morpheusdata.core.backup.BackupProvider } and
	 * {@link com.morpheusdata.core.backup.BackupTypeProvider} supply configuration, there may be situations where the instance
	 * configuration will determine which options need to be presented in the restore wizard.
	 * <p>
	 * Available Restore options:
	 * 		<ul>
	 * 		 	<li>
	 * 		 	    restoreExistingEnabled (Boolean) -- determines the visibility of the restore to existing option
	 * 		 	</li>
	 * 		 	<li>
	 * 		 	  	restoreNewEnabled (Boolean) -- determines the visibility of the restore to new option
	 * 		 	</li>
	 * 		 	<li>
	 * 		 	  	name (String) -- default name of the restored instance
	 * 		 	</li>
	 * 		 	<li>
	 * 		 		hostname (String) -- default hostname of the restored instance
	 * 		 	</li>
	 * 		</ul>
	 *
	 * @param backupModel the backup
	 * @param opts optional parameters
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse getRestoreOptions(Backup backup, Map opts) {
		return ServiceResponse.success()
	}

	/**
	 * Execute the backup restore on the external system
	 * @param backupRestoreModel restore to be executed
	 * @param backupResultModel refernce to the backup result
	 * @param backupModel reference to the backup associated with the backup result
	 * @param opts optional parameters
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse restoreBackup(BackupRestore backupRestore, BackupResult backupResult, Backup backup, Map opts) {
		ServiceResponse response = ServiceResponse.prepare(new BackupRestoreResponse(backupRestore))
		try {
			log.debug("restoreBackup, restore: {}, source: {}, opts: {}", backupRestore, backupResult, opts)
			def backupProvider = backup.backupProvider
			def authConfig = apiService.getAuthConfig(backupProvider)
			def containerId = opts.containerId ?: backup?.containerId
			def container = morpheusContext.services.workload.get(containerId)
			def server = container.server
			def resourceGroup = backup.getConfigProperty('resourceGroup')
			def vault = backup.getConfigProperty('vault')
			def protectedItemName = backup.getConfigProperty('protectedItemName')
			def containerName = backup.getConfigProperty('containerName')
			def vmId = backup.getConfigProperty('vmId')
			def instanceConfig = backupResult.getConfigMap().instanceConfig
			def datastoreId = instanceConfig.volumes.getAt(0).datastoreId
			def poolId = instanceConfig.config.resourcePoolId
			def datastore = morpheusContext.services.cloud.datastore.get(datastoreId as Long)
			def pool = poolId?.startsWith('pool-') ? morpheusContext.services.cloud.pool.get(poolId.substring(5) as Long) : null
			HttpApiClient client = new HttpApiClient()
			def body = [
				properties: [
					objectType: 'IaasVMRestoreRequest',
					sourceResourceId: vmId,
					storageAccountId: datastore.internalId,
					region: pool.regionCode,
					recoveryPointId: backupResult.externalId,
				]
			]
			def newServerId
			if(opts.restoreType == 'new' && opts.containerId && opts.containerId != backup.containerId) {
				def networkConfig = instanceConfig.networkInterfaces.network.getAt(0)
				def subnet = networkConfig.subnet?.startsWith('subnet-') ? morpheusContext.services.networkSubnet.get(networkConfig.subnet.substring(7) as Long) : null
				def network = networkConfig.id?.startsWith('network-') ? morpheusContext.services.network.get(networkConfig.id.substring(8) as Long) : null

				def existingNames = morpheusContext.services.computeServer.list(
					new DataQuery().withFilters(
						new DataFilter('cloud.id', backup.zoneId),
						new DataFilter('resourcePool.id', pool.id)
					)
				)?.collect { it.externalId }

				newServerId = buildAzureInternalName(authConfig, server.name, resourceGroup, existingNames, client)
				body.properties.recoveryType = 'AlternateLocation'
				body.properties.targetVirtualMachineId = pool.internalId + '/providers/Microsoft.Compute/virtualmachines/' + newServerId
				body.properties.targetResourceGroupId = pool.internalId
				body.properties.virtualNetworkId = network.externalId
				body.properties.subnetId = subnet.externalId
				body.properties.createNewCloudService = false
				body.properties.originalStorageAccountOption = false
				body.properties.encryptionDetails = [
					encryptionEnabled: false
				]
			} else {
				body.properties.recoveryType = 'OriginalLocation'
				body.properties.createNewCloudService = false
				body.properties.originalStorageAccountOption = false
				body.properties.affinityGroup = ''
				body.properties.diskEncryptionSetId = null
				body.properties.subnetId = null
				body.properties.targetDomainNameId = null
				body.properties.targetResourceGroupId = null
				body.properties.targetVirtualMachineId = null
				body.properties.virtualNetworkId = null
			}
			def restoreResponse = apiService.restoreVm(authConfig, [resourceGroup: resourceGroup, vault: vault, containerName: containerName, protectedItemName: protectedItemName, body: body, recoveryPointId: backupResult.externalId, client: client])
			if(restoreResponse.success == true && restoreResponse.statusCode == '202') {
				response.success = true
				response.msg = "Restore started"

				// fetch the restore job
				def jobId
				sleep(1000)
				def attempts = 0
				def keepGoing = true
				while(keepGoing) {
					def asyncResponse = apiService.getAsyncOpertationStatus(authConfig, [url: restoreResponse.results, client: client])
					log.info("asyncResponse: ${asyncResponse}")
					if((asyncResponse.success == true && asyncResponse.results?.properties?.jobId) || attempts > 9) {
						keepGoing = false
						jobId = asyncResponse.results?.properties?.jobId
						backupRestore.externalStatusRef = jobId
						backupRestore.status = BackupRestore.Status.IN_PROGRESS.toString()
						if(newServerId) {
							server.externalId = newServerId
							morpheusContext.services.computeServer.save(server)
						}
						response.data.updates = true
						response.success = true
					}

					if(keepGoing) {
						sleep(1000)
						attempts++
					}
				}
				if(!jobId) {
					response.success = false
					backupRestore.status = BackupRestore.Status.FAILED.toString()
					backupRestore.errorMessage = "Failed to start restore"
					response.data.updates = true
				}
			} else {
				response.success = false
				backupRestore.errorMessage = restoreResponse.msg
				backupRestore.status = BackupRestore.Status.FAILED.toString()
				response.data.updates = true

				if(container.instance?.id) {
					def instance = morpheus.services.instance.get(container.instance.id)
					if(instance) {
						instance.status = Instance.Status.failed.toString()
						morpheus.services.instance.save(instance)
					}
				}
			}
		} catch (e) {
			log.error("restoreBackup error", e)
			response.error = "Failed to restore Commvault backup: ${e}"
		}
		return response
	}

	/**
	 * Periodically check for any updates to an in-progress restore. This method will be executed every 60 seconds for
	 * the restore while the restore has a status of `START_REQUESTED` or `IN_PROGRESS`. Any other status will indicate
	 * the restore has completed and does not need to be refreshed. The primary use case for this method is long-running
	 * restores to avoid consuming resources during the restore process.
	 * @param backupRestore the running restore
	 * @param backupResult backup result referencing the backup to be restored
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse refreshBackupRestoreResult(BackupRestore backupRestore, BackupResult backupResult) {
		log.debug("refreshBackupRestoreResult: backupRestore: ${backupRestore.dump()}")
		ServiceResponse<BackupRestoreResponse> rtn = ServiceResponse.prepare(new BackupRestoreResponse(backupRestore))
		def backup = backupResult.backup
		def backupProvider = backup.backupProvider

		try {
			if (!backupProvider?.enabled) {
				rtn.msg = "BackupProvider not enabled"
				return rtn
			}
			def authConfig = apiService.getAuthConfig(backupProvider)
			def backupJobId = backupRestore.externalStatusRef
			def resourceGroup = backup.getConfigProperty('resourceGroup')
			def vault = backup.getConfigProperty('vault')
			if(backupJobId) {
				def getBackupJobResult = apiService.getBackupJob(authConfig, [resourceGroup: resourceGroup, vault: vault, jobId: backupJobId])
				log.info("getBackupJobResult: ${getBackupJobResult}")
				if (getBackupJobResult.success == true && getBackupJobResult.results) {
					def backupJob = getBackupJobResult.results
					boolean doUpdate = false
					log.info("backupJob: ${backupJob}")

					def restoreStatus = AzureBackupUtility.getBackupStatus(backupJob.properties.status)
					if(rtn.data.backupRestore.status != restoreStatus) {
						rtn.data.backupRestore.status = restoreStatus
						doUpdate = true
					}
					if(backupJob.properties.startTime && backupJob.properties.endTime) {
						def startDate = AzureBackupUtility.parseDate(backupJob.properties.startTime)
						def endDate = AzureBackupUtility.parseDate(backupJob.properties.endTime)
						if (startDate && rtn.data.backupRestore.startDate != startDate) {
							rtn.data.backupRestore.startDate = startDate
							doUpdate = true
						}
						if (endDate && rtn.data.backupRestore.endDate != endDate) {
							rtn.data.backupRestore.endDate = endDate
							doUpdate = true
						}
						def duration = (endDate && startDate) ? (endDate.time - startDate.time) : 0
						if (rtn.data.backupRestore.duration != duration) {
							rtn.data.backupRestore.duration = duration
							doUpdate = true
						}
					}
					if(doUpdate) {
						rtn.data.backupRestore.lastUpdated = new Date()
					}

					if(restoreStatus == BackupResult.Status.SUCCEEDED.toString()) {
						def targetWorkload = morpheusContext.services.workload.get(backupRestore.containerId)
						morpheusContext.async.backup.backupRestore.finalizeRestore(targetWorkload)
					}

					rtn.data.updates = doUpdate
					rtn.success = true
				}

			}
		}
		catch (Exception ex) {
			log.error("refreshBackupRestoreResult error", ex)
		}

		return rtn
	}

	private buildAzureInternalName(Map authConfig, name, resourceGroup, existingNames = [], client = null) {
		def internalName = name.replaceAll(/[^a-zA-Z0-9\- ]/, '')
		def takeLength = 15
		internalName = internalName.replaceAll(/\W+/,'-')?.take(takeLength)
		while(internalName.endsWith('-')) {
			internalName = internalName[0..-2] //lop off ending hyphens as these conflict in azure
		}
		def originalInternalName = internalName
		def serverResults = apiService.getServer(authConfig, [externalId: internalName, resourceGroup: resourceGroup, client: client])
		def seq = 1
		log.debug("Existing Names ${existingNames}")
		while(serverResults.success || existingNames?.contains(internalName.toString())) {
			def sequence = "${seq++}"
			def originalEndsWithDash = originalInternalName.endsWith('-')
			def suffix = originalEndsWithDash ? sequence : "-${sequence}"
			def suffixLength = suffix.size()

			def namePrefix = originalInternalName.take(takeLength-suffixLength)
			internalName = "${namePrefix}${suffix}"

			if(existingNames?.contains(internalName.toString()) ) {
				log.debug("Name ${internalName} already used internally")
			} else {
				serverResults = apiService.getServer(authConfig, [externalId: internalName, resourceGroup: resourceGroup, client: client])
			}
		}
		return internalName
	}
}
